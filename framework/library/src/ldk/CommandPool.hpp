/*******************************************************************************
 * This file is part of openWNS (open Wireless Network Simulator)
 * _____________________________________________________________________________
 *
 * Copyright (C) 2004-2007
 * Chair of Communication Networks (ComNets)
 * Kopernikusstr. 5, D-52074 Aachen, Germany
 * phone: ++49-241-80-27910,
 * fax: ++49-241-80-22242
 * email: info@openwns.org
 * www: http://www.openwns.org
 * _____________________________________________________________________________
 *
 * openWNS is free software; you can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License version 2 as published by the
 * Free Software Foundation;
 *
 * openWNS is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 ******************************************************************************/

#ifndef WNS_LDK_COMMANDPOOL_HPP
#define WNS_LDK_COMMANDPOOL_HPP

#include <WNS/ldk/CommandProxy.hpp>

#include <WNS/osi/PDU.hpp>
#include <WNS/osi/PCI.hpp>
#include <WNS/container/Registry.hpp>

#include <vector>

namespace wns { namespace ldk {

	class FunctionalUnit;
	class Command;
	class CommandTypeSpecifierInterface;

	/**
	 * @brief Build a PCI from a set of Commands.
	 * @ingroup commandtypespecifier
	 *
	 * A Layer may consist of serveral functional units. Each of these functional units
	 * may need some additional elements within the PCI. Since the composition
	 * of functional units into a Layer is done at runtime, there is no easy way
	 * to build a PCI in advance.
	 * <p>
	 * There are two possible solutions to this problem:
	 * <ul>
	 * <li> create new PDU containing the old PDU together with new PCI
	 *      in every CommandTypeSpecifier that needs additional control information.
	 * <li> use a container to keep a commandPool of partial PCIs that
	 *      together form the PCI of the whole Layer.
	 * </ul>
	 *
	 * There are two problems concerning the first approach. The first is what
	 * we call the 'onion phenomenon'. Different functional units may have the need to
	 * access control information generated by other functional units, but there
	 * is no simple way to tell how many levels of compounds have to be unpacked to
	 * get the desired PCI (given that the stacking of functional units is determined
	 * at runtime). The second problem is the runtime overhead introduced by
	 * a lot of additional new/delete calls for wrapping compounds several times.
	 * <p>
	 * This is why we chose the second approach. CommandPool is a PCI
	 * built from a set of Commands. A CommandPool will never be accessed
	 * directly. Use a CommandProxy instead.
	 *
	 */
	class CommandPool :
		public wns::osi::PCI
	{
		// Only CommandProxy instances are allowed to create new CommandPool
		// instances and access their data directly.
		friend class CommandProxy;

		typedef std::vector<CommandProxy::CommandIDType> PathContainer;
		typedef std::vector<Command*> CommandContainer;
		// typedef wns::container::Registry<CommandProxy::CommandIDType, Command*> CommandContainer;

	public:
		/**
		 * @brief Copy constructor - call copy constructors of all Commands.
		 *
		 * Availability of a copy constructor is essential for the concept of
		 * CommandPools in case of segmentation and reassembly.
		 * <p>
		 * Whenever a PDU gets segmented, its PCI is copied for every new PDU.
		 * <p>
		 * The first mutated Command within each copy will usually be the
		 * SAR PCI.
		 * <p>
		 * The corresponding SAR Entity (FunctionalUnit) will combine the incoming
		 * SDUs, discarding all received segments and creates a fresh
		 * PCI as result of the reassembly.
		 * <p>
		 * It is not allowed to change any Command that has been activated before
		 * segmentation between segmentation and reassembly.
		 * The reassembler may assert that.
		 */
		CommandPool(const CommandPool& that);

		/**
		 * @brief Destructor - call destructor of all Commands.
		 *
		 */
		~CommandPool();

		/**
		 * @brief Size calculation.
		 *
		 * Delegates size calculation to the CommandProxy. See CommandProxy::calculateSizes for
		 * an explanation.
		 *
		 */
		void
		calculateSizes(
			Bit& commandPoolSize,
			Bit& dataSize,
			const FunctionalUnit* questioner = NULL) const;

		/**
		 * @brief Introduce the SDU to describe.
		 *
		 */
		virtual void
		setSDUPtr(wns::osi::PDUPtr& sdu);

		/**
		 * @brief Dumps the types of the CommandPool for debugging purposes
		 *
		 */
		virtual std::string
		dumpCommandTypes() const;

		bool
		knowsSameCommandsAs(const CommandPool& other) const;

		/**
		 * @brief get the FUN where this CommandPool was created
		 */
		const fun::FUN*
		getOrigin() const { return origin; }

		void
		setReceiver(const fun::FUN* rec) { receiver = rec; }

		const fun::FUN*
		getReceiver() const { return receiver; }

#ifndef NDEBUG
		virtual size_t
		calcObjSize() const;
#endif
	protected:
		/**
		 * @brief Low-level constructor.
		 *
		 * The created CommandPool will stay completely uninitialized. Don't call
		 * this if you aren't the CommandProxy proxy.
		 *
		 */
		CommandPool(const CommandProxy* proxy,
			    const fun::FUN* orig);

		/**
		 * @brief Stores the path of the commandPool through the functional units.
		 *
		 * Functional units are stored in the order they activated their Commands. Because of that,
		 * each FunctionalUnit of a Layer may only occour once within the path.
		 * path is mutated and accessed directly by the CommandProxy. It is used to perform
		 * partial copying (CommandProxy::partialCopy).
		 *
		 */
		PathContainer path;

	private:
		/**
		 * @brief Insert a Command into the CommandPool
		 */
		void
		insert(
			const CommandProxy::CommandIDType& id,
			Command* command);

		/**
		 * @brief find a Command in the CommandPool
		 */
		Command*
		find(const CommandProxy::CommandIDType& id) const;

		/**
		 * @brief Returns true if a Command is part of a CommandPool 
		 */
		bool
		knows(const CommandProxy::CommandIDType& id) const;

		/**
		 * @brief This is my creator, he knows my layout and internals.
		 *
		 */
		const CommandProxy* proxy;

		/**
		 * @brief Commands are stored here
		 */
		CommandContainer commands;

		/**
		 * @brief Origin where this commandPool was created
		 */
		const wns::ldk::fun::FUN* origin;

		/**
		 * @brief Receiver where this commandPool is consumed (can be
		 * set and read externally)
		 */
		const wns::ldk::fun::FUN* receiver;
	};

} // ldk
} // wns

#endif // NOT defined WNS_LDK_COMMANDPOOL_HPP


